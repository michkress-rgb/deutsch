<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>3x + 1 (Collatz) Game</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#171a2b; --panel2:#1e2240;
      --text:#e9ecff; --muted:#a9b1ff; --accent:#7aa2ff; --good:#5ee28f; --warn:#ffcc66; --bad:#ff6b6b;
      --line:rgba(255,255,255,.12);
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    html,body{height:100%}
    body{
      margin:0; background: radial-gradient(1200px 700px at 20% 10%, #1a1f3b 0%, var(--bg) 55%, #090b14 100%);
      color:var(--text); font-family:var(--sans);
      display:flex; align-items:flex-start; justify-content:center;
      padding:24px;
    }
    .app{width:min(1100px,100%); display:grid; gap:14px; grid-template-columns: 1.15fr .85fr;}
    @media (max-width: 980px){ .app{grid-template-columns:1fr} }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius:16px;
      box-shadow: 0 18px 50px rgba(0,0,0,.35);
      overflow:hidden;
    }
    header{
      padding:18px 18px 10px;
      border-bottom:1px solid var(--line);
      background: linear-gradient(180deg, rgba(122,162,255,.18), rgba(255,255,255,0));
    }
    header h1{margin:0; font-size:18px; letter-spacing:.3px}
    header p{margin:6px 0 0; color:var(--muted); font-size:13px; line-height:1.35}
    .content{padding:16px 18px}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .row + .row{margin-top:10px}
    label{font-size:12px; color:var(--muted)}
    input[type="text"], input[type="number"]{
      background:rgba(0,0,0,.25);
      border:1px solid var(--line);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-size:14px;
      outline:none;
      min-width: 220px;
    }
    input[type="range"]{width:240px}
    button{
      background: linear-gradient(180deg, rgba(122,162,255,.95), rgba(122,162,255,.75));
      color:#0b1020;
      border:none;
      padding:10px 12px;
      border-radius:12px;
      font-weight:700;
      cursor:pointer;
      box-shadow: 0 10px 25px rgba(122,162,255,.25);
    }
    button.secondary{
      background: rgba(255,255,255,.08);
      color: var(--text);
      border:1px solid var(--line);
      box-shadow:none;
      font-weight:600;
    }
    button.danger{
      background: rgba(255,107,107,.16);
      color: var(--text);
      border:1px solid rgba(255,107,107,.35);
      box-shadow:none;
      font-weight:700;
    }
    button:disabled{opacity:.5; cursor:not-allowed}
    .statgrid{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:10px;
    }
    @media (max-width: 980px){ .statgrid{grid-template-columns: repeat(2, minmax(0,1fr));} }
    .stat{
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px 12px 10px;
      min-height: 64px;
    }
    .stat .k{font-size:11px; color:var(--muted); margin-bottom:6px}
    .stat .v{font-family:var(--mono); font-size:15px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
    }
    .pill strong{color:var(--text)}
    .good{color:var(--good)}
    .warn{color:var(--warn)}
    .bad{color:var(--bad)}
    .mono{font-family:var(--mono)}
    .divider{height:1px; background:var(--line); margin:14px 0}
    .log{
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px;
      max-height: 270px;
      overflow:auto;
      font-family:var(--mono);
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }
    canvas{
      width:100%;
      height:240px;
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      border-radius:14px;
      display:block;
    }
    .small{font-size:12px; color:var(--muted); line-height:1.35}
    .leader{
      display:grid; gap:10px;
    }
    .leader .item{
      background:rgba(0,0,0,.22);
      border:1px solid var(--line);
      border-radius:14px;
      padding:10px 12px;
      display:flex; justify-content:space-between; gap:10px;
      font-family:var(--mono);
      font-size:12px;
    }
    .toast{
      position:fixed; left:50%; transform:translateX(-50%);
      bottom:18px; padding:10px 12px;
      background:rgba(0,0,0,.65);
      border:1px solid var(--line);
      border-radius:12px;
      color:var(--text);
      font-size:13px;
      opacity:0; pointer-events:none;
      transition:opacity .2s ease;
    }
    .toast.show{opacity:1}
    .hint{
      font-size:12px; color:var(--muted);
    }
    .kbd{
      font-family:var(--mono);
      border:1px solid var(--line);
      background:rgba(255,255,255,.06);
      padding:2px 6px;
      border-radius:7px;
      color:var(--text);
      font-size:12px;
    }
  </style>
</head>

<body>
  <div class="app">
    <!-- Main game -->
    <section class="card">
      <header>
        <h1>3x + 1 (Collatz) Game</h1>
        <p>
          Pick a positive integer. The game applies the rule until it reaches 1:
          if <span class="mono">n</span> is even, do <span class="mono">n / 2</span>; if odd, do <span class="mono">3n + 1</span>.
          The conjecture says every start eventually reaches 1 (not proven).
        </p>
      </header>

      <div class="content">
        <div class="row">
          <div style="display:flex; flex-direction:column; gap:6px;">
            <label for="start">Your number (supports very large integers)</label>
            <input id="start" type="text" inputmode="numeric" placeholder="e.g., 27" />
          </div>

          <button id="btnStart">Start</button>
          <button id="btnStep" class="secondary" disabled>Step</button>
          <button id="btnRun" class="secondary" disabled>Auto-run</button>
          <button id="btnPause" class="secondary" disabled>Pause</button>
          <button id="btnReset" class="danger" disabled>Reset</button>
        </div>

        <div class="row">
          <span class="pill">Mode: <strong id="modeLabel">Idle</strong></span>
          <span class="pill">Goal: <strong>Reach 1</strong></span>
          <span class="pill">Controls: <span class="kbd">Enter</span> start, <span class="kbd">Space</span> step, <span class="kbd">R</span> reset</span>
        </div>

        <div class="divider"></div>

        <div class="statgrid">
          <div class="stat"><div class="k">Current n</div><div class="v" id="curN">—</div></div>
          <div class="stat"><div class="k">Steps so far</div><div class="v" id="steps">0</div></div>
          <div class="stat"><div class="k">Peak value seen</div><div class="v" id="peak">—</div></div>
          <div class="stat"><div class="k">Rule applied</div><div class="v" id="rule">—</div></div>
          <div class="stat"><div class="k">Starting number</div><div class="v" id="startN">—</div></div>
          <div class="stat"><div class="k">Badge</div><div class="v" id="badge">—</div></div>
        </div>

        <div class="row" style="margin-top:12px;">
          <div style="display:flex; flex-direction:column; gap:6px;">
            <label for="speed">Auto-run speed</label>
            <input id="speed" type="range" min="10" max="500" value="140" />
            <div class="hint"><span class="mono" id="speedLabel">140</span> ms per step</div>
          </div>

          <div style="display:flex; flex-direction:column; gap:6px;">
            <label for="maxSteps">Safety cap (max steps)</label>
            <input id="maxSteps" type="number" min="1" max="5000000" value="100000" />
            <div class="hint">Prevents runaway loops if something goes wrong.</div>
          </div>

          <div style="display:flex; flex-direction:column; gap:6px;">
            <label for="showSeq">Sequence display</label>
            <div class="row" style="gap:8px;">
              <button id="toggleSeq" class="secondary" disabled>Show sequence</button>
              <button id="copySeq" class="secondary" disabled>Copy</button>
            </div>
          </div>
        </div>

        <div class="row" style="margin-top:10px;">
          <canvas id="plot" width="900" height="260" aria-label="Plot of values over time"></canvas>
        </div>

        <div id="seqWrap" style="display:none; margin-top:10px;">
          <div class="small">Sequence (first values shown; very long sequences will be truncated visually but still stored for copy).</div>
          <div class="log" id="seqLog"></div>
        </div>
      </div>
    </section>

    <!-- Side panel: challenge + leaderboard -->
    <aside class="card">
      <header>
        <h1>Challenge mode</h1>
        <p>
          Try to pick a number that takes many steps to reach 1. Your best runs are saved locally in this browser.
        </p>
      </header>
      <div class="content">
        <div class="row">
          <button id="btnRandom" class="secondary">Random pick</button>
          <button id="btnSave" class="secondary" disabled>Save run</button>
          <button id="btnClear" class="danger">Clear leaderboard</button>
        </div>

        <div class="divider"></div>

        <div class="small">
          Scoring is based on steps. If two runs tie, the one with higher peak ranks higher.
        </div>

        <div class="divider"></div>

        <div class="leader" id="leaderboard"></div>

        <div class="divider"></div>

        <div class="small">
          Note: This uses JavaScript <span class="mono">BigInt</span>, so very large integers work, but huge sequences can still be slow.
        </div>
      </div>
    </aside>
  </div>

  <div class="toast" id="toast"></div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const startEl = $("start");
  const btnStart = $("btnStart");
  const btnStep = $("btnStep");
  const btnRun = $("btnRun");
  const btnPause = $("btnPause");
  const btnReset = $("btnReset");
  const btnRandom = $("btnRandom");
  const btnSave = $("btnSave");
  const btnClear = $("btnClear");
  const toggleSeq = $("toggleSeq");
  const copySeq = $("copySeq");

  const modeLabel = $("modeLabel");
  const speedEl = $("speed");
  const speedLabel = $("speedLabel");
  const maxStepsEl = $("maxSteps");

  const curNEl = $("curN");
  const stepsEl = $("steps");
  const peakEl = $("peak");
  const ruleEl = $("rule");
  const startNEl = $("startN");
  const badgeEl = $("badge");

  const seqWrap = $("seqWrap");
  const seqLog = $("seqLog");

  const plot = $("plot");
  const ctx = plot.getContext("2d");

  const toast = $("toast");

  // Game state
  let running = false;
  let timer = null;

  let startN = null;       // BigInt
  let n = null;            // BigInt
  let steps = 0;
  let peak = null;         // BigInt
  let history = [];        // array of BigInt
  let ruleText = "—";
  let reachedOne = false;

  const LS_KEY = "collatz_leaderboard_v1";

  function showToast(msg){
    toast.textContent = msg;
    toast.classList.add("show");
    setTimeout(() => toast.classList.remove("show"), 1400);
  }

  function sanitizeIntegerString(s){
    // Allow leading/trailing spaces, optional +, digits only otherwise.
    const t = String(s).trim();
    if (t === "") return null;
    const m = t.match(/^\+?\d+$/);
    if (!m) return null;
    // Remove leading plus +, keep zeros as-is.
    return t.replace(/^\+/, "");
  }

  function parseBigIntFromInput(){
    const cleaned = sanitizeIntegerString(startEl.value);
    if (!cleaned) return { ok:false, err:"Please enter a positive integer (digits only)." };
    try{
      const bi = BigInt(cleaned);
      if (bi <= 0n) return { ok:false, err:"Please enter an integer greater than 0." };
      return { ok:true, value:bi };
    }catch{
      return { ok:false, err:"That number is too large or invalid for BigInt parsing." };
    }
  }

  function badgeFor(stepsCount, peakValue){
    // Simple, game-like badges:
    if (!reachedOne) return "—";
    if (stepsCount <= 15) return "Quick Finish";
    if (stepsCount <= 60) return "Steady Climber";
    // Peak thresholds (approx, by digit count)
    const digits = peakValue.toString().length;
    if (stepsCount >= 300 && digits >= 8) return "Skyrocketer";
    if (stepsCount >= 200) return "Long Haul";
    if (digits >= 10) return "Giant Numbers";
    return "Explorer";
  }

  function setMode(text){
    modeLabel.textContent = text;
  }

  function setButtonsForState(){
    const hasGame = startN !== null;
    btnStep.disabled = !hasGame || running || reachedOne;
    btnRun.disabled = !hasGame || running || reachedOne;
    btnPause.disabled = !hasGame || !running;
    btnReset.disabled = !hasGame;

    btnSave.disabled = !hasGame || !reachedOne;

    toggleSeq.disabled = !hasGame;
    copySeq.disabled = !hasGame;
  }

  function resetGame(){
    stopAuto();
    running = false;
    startN = null;
    n = null;
    steps = 0;
    peak = null;
    history = [];
    ruleText = "—";
    reachedOne = false;

    curNEl.textContent = "—";
    stepsEl.textContent = "0";
    peakEl.textContent = "—";
    ruleEl.textContent = "—";
    startNEl.textContent = "—";
    badgeEl.textContent = "—";

    seqLog.textContent = "";
    seqWrap.style.display = "none";
    toggleSeq.textContent = "Show sequence";

    clearPlot();
    setMode("Idle");
    setButtonsForState();
  }

  function startGame(){
    const parsed = parseBigIntFromInput();
    if (!parsed.ok){
      showToast(parsed.err);
      return;
    }
    stopAuto();
    running = false;

    startN = parsed.value;
    n = startN;
    steps = 0;
    peak = startN;
    history = [startN];
    ruleText = "—";
    reachedOne = (n === 1n);

    startNEl.textContent = startN.toString();
    curNEl.textContent = n.toString();
    stepsEl.textContent = "0";
    peakEl.textContent = peak.toString();
    ruleEl.textContent = "—";
    badgeEl.textContent = reachedOne ? badgeFor(0, peak) : "—";

    setMode(reachedOne ? "Done" : "Ready");
    clearPlot();
    plotHistory();
    updateSequenceView();
    setButtonsForState();

    if (reachedOne) showToast("Already at 1. Try another number.");
  }

  function stepOnce(){
    if (startN === null || reachedOne) return;

    const cap = Number(maxStepsEl.value || 100000);
    if (steps >= cap){
      stopAuto();
      setMode("Stopped");
      showToast("Safety cap reached. Increase the cap to continue.");
      setButtonsForState();
      return;
    }

    // Collatz rule
    if (n % 2n === 0n){
      n = n / 2n;
      ruleText = "even → n / 2";
    } else {
      n = 3n * n + 1n;
      ruleText = "odd → 3n + 1";
    }

    steps += 1;
    if (n > peak) peak = n;
    history.push(n);

    reachedOne = (n === 1n);

    curNEl.textContent = n.toString();
    stepsEl.textContent = String(steps);
    peakEl.textContent = peak.toString();
    ruleEl.textContent = ruleText;

    if (reachedOne){
      stopAuto();
      setMode("Done");
      badgeEl.textContent = badgeFor(steps, peak);
      showToast("Reached 1.");
    } else {
      badgeEl.textContent = "—";
      setMode(running ? "Auto-running" : "Ready");
    }

    plotHistory();
    updateSequenceView();
    setButtonsForState();
  }

  function startAuto(){
    if (startN === null || reachedOne) return;
    if (running) return;
    running = true;
    setMode("Auto-running");
    setButtonsForState();

    const tick = () => {
      if (!running) return;
      stepOnce();
      if (!running) return; // may stop when reaching 1 or cap
      timer = setTimeout(tick, Number(speedEl.value));
    };
    timer = setTimeout(tick, Number(speedEl.value));
  }

  function stopAuto(){
    running = false;
    if (timer) clearTimeout(timer);
    timer = null;
    setButtonsForState();
  }

  function updateSequenceView(){
    if (startN === null) return;
    // Keep log readable: show first ~120 and last ~40 when huge
    const MAX_SHOW = 160;
    const arr = history.map(x => x.toString());
    let view = "";
    if (arr.length <= MAX_SHOW){
      view = arr.join(" → ");
    } else {
      const head = arr.slice(0, 120);
      const tail = arr.slice(-40);
      view = head.join(" → ") + "\n… (" + (arr.length - 160) + " hidden values) …\n" + tail.join(" → ");
    }
    seqLog.textContent = view;
  }

  function clearPlot(){
    ctx.clearRect(0,0,plot.width,plot.height);
    // subtle baseline grid
    ctx.globalAlpha = 0.18;
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#ffffff";
    ctx.beginPath();
    for (let i=1;i<6;i++){
      const y = (plot.height/6)*i;
      ctx.moveTo(0,y);
      ctx.lineTo(plot.width,y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function plotHistory(){
    clearPlot();
    if (!history.length) return;

    // Use log scale for y to keep huge spikes visible.
    const ys = history.map(v => {
      const asNum = Number(v <= 9007199254740991n ? v : 9007199254740991n); // clamp for Number conversion
      // If extremely big, approximate by digit count.
      if (v > 9007199254740991n) {
        const digits = v.toString().length;
        return Math.log10(1 + digits) * 10;
      }
      return Math.log10(1 + asNum);
    });

    const maxY = Math.max(...ys);
    const minY = Math.min(...ys);

    const pad = 14;
    const w = plot.width - pad*2;
    const h = plot.height - pad*2;

    const N = ys.length;
    const xAt = (i) => pad + (N === 1 ? 0 : (i/(N-1))*w);
    const yAt = (y) => pad + (1 - ((y - minY) / (maxY - minY || 1))) * h;

    // Path
    ctx.lineWidth = 2;
    ctx.strokeStyle = "#ffffff";
    ctx.globalAlpha = 0.85;
    ctx.beginPath();
    for (let i=0;i<N;i++){
      const x = xAt(i), y = yAt(ys[i]);
      if (i === 0) ctx.moveTo(x,y);
      else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Current point marker
    const cx = xAt(N-1), cy = yAt(ys[N-1]);
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(cx, cy, 4, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // Caption
    ctx.globalAlpha = 0.6;
    ctx.fillStyle = "#ffffff";
    ctx.font = "12px " + getComputedStyle(document.body).fontFamily;
    ctx.fillText("Value over time (log scale)", pad, 18);
    ctx.globalAlpha = 1;
  }

  function toggleSequence(){
    if (seqWrap.style.display === "none"){
      seqWrap.style.display = "block";
      toggleSeq.textContent = "Hide sequence";
    } else {
      seqWrap.style.display = "none";
      toggleSeq.textContent = "Show sequence";
    }
  }

  async function copySequence(){
    if (!history.length){
      showToast("Nothing to copy yet.");
      return;
    }
    const text = history.map(x => x.toString()).join(" -> ");
    try{
      await navigator.clipboard.writeText(text);
      showToast("Sequence copied.");
    }catch{
      showToast("Copy failed (clipboard permission).");
    }
  }

  function randomPick(){
    // Weighted to include some known “interesting” ranges but still varied.
    const presets = [27, 97, 871, 6171, 77031, 837799];
    const r = Math.random();
    let v;
    if (r < 0.35){
      v = presets[Math.floor(Math.random()*presets.length)];
    } else {
      // random 1..1,000,000 with bias toward mid/high
      const a = Math.floor(Math.random()*1000);
      const b = Math.floor(Math.random()*1000);
      v = (a*b) + 1;
    }
    startEl.value = String(v);
    showToast("Random number picked.");
  }

  // Leaderboard
  function loadBoard(){
    try{
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return [];
      const arr = JSON.parse(raw);
      if (!Array.isArray(arr)) return [];
      return arr;
    }catch{ return []; }
  }

  function saveBoard(entries){
    localStorage.setItem(LS_KEY, JSON.stringify(entries));
  }

  function renderBoard(){
    const board = loadBoard();
    const wrap = $("leaderboard");
    wrap.innerHTML = "";

    if (!board.length){
      const div = document.createElement("div");
      div.className = "small";
      div.textContent = "No saved runs yet. Finish a run (reach 1) and click “Save run”.";
      wrap.appendChild(div);
      return;
    }

    board
      .sort((a,b) => (b.steps - a.steps) || (b.peakDigits - a.peakDigits))
      .slice(0, 12)
      .forEach((e, idx) => {
        const item = document.createElement("div");
        item.className = "item";
        const left = document.createElement("div");
        left.textContent = `#${idx+1} start=${e.start} steps=${e.steps}`;
        const right = document.createElement("div");
        right.textContent = `peak≈${e.peakDigits} digits`;
        item.appendChild(left);
        item.appendChild(right);
        wrap.appendChild(item);
      });
  }

  function saveRun(){
    if (!reachedOne || startN === null) return;
    const board = loadBoard();

    const entry = {
      start: startN.toString(),
      steps: steps,
      peakDigits: peak.toString().length,
      at: Date.now()
    };

    board.push(entry);
    // keep reasonable size
    board.sort((a,b) => (b.steps - a.steps) || (b.peakDigits - a.peakDigits));
    saveBoard(board.slice(0, 40));

    renderBoard();
    showToast("Run saved.");
  }

  function clearBoard(){
    localStorage.removeItem(LS_KEY);
    renderBoard();
    showToast("Leaderboard cleared.");
  }

  // Events
  btnStart.addEventListener("click", startGame);
  btnStep.addEventListener("click", stepOnce);
  btnRun.addEventListener("click", startAuto);
  btnPause.addEventListener("click", () => { stopAuto(); setMode(reachedOne ? "Done" : "Ready"); });
  btnReset.addEventListener("click", resetGame);

  btnRandom.addEventListener("click", randomPick);
  btnSave.addEventListener("click", saveRun);
  btnClear.addEventListener("click", clearBoard);

  toggleSeq.addEventListener("click", toggleSequence);
  copySeq.addEventListener("click", copySequence);

  speedEl.addEventListener("input", () => speedLabel.textContent = speedEl.value);

  // Keyboard shortcuts
  document.addEventListener("keydown", (e) => {
    if (e.key === "Enter"){
      if (document.activeElement === startEl) startGame();
      return;
    }
    if (e.key === " "){
      e.preventDefault();
      if (!btnStep.disabled) stepOnce();
      return;
    }
    if (e.key.toLowerCase() === "r"){
      if (!btnReset.disabled) resetGame();
      return;
    }
  });

  // Initial
  speedLabel.textContent = speedEl.value;
  clearPlot();
  renderBoard();
  setButtonsForState();
})();
</script>
</body>
</html>
